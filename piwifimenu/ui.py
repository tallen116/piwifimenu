import logging
import pygame
import pygame_menu
import pygame_vkeyboard
import piwifimenu.wifi as wifi

logger = logging.getLogger(__name__)


class user_interface:
    """
    A class that will generate menus.

    Methods:
    --------

    """
    SCREEN_WIDTH = None
    SCREEN_HEIGHT = None

    theme = None
    main_menu = None
    option_menu = None
    wifi_menu = None
    wifi_config_menu = None
    _toggled = False
    _exit = False
    # List of networks
    networks = None
    # Network and Menu mapper
    networks_menu = None

    def __init__(self):
        """
        Initialize the user_interface class.
        """
        logger.info("Initialize user interface")
        self.networks = wifi.get_wifi_config()
        self.SCREEN_WIDTH = pygame.display.get_surface().get_width()
        self.SCREEN_HEIGHT = pygame.display.get_surface().get_height()
        self._theme()
        self._wifi_menu()
        self._option_menu()
        self._main_menu()

    def exit(self):
        logger.info('Exit called from UI')
        self._exit = True

    def exit_status(self):
        return self._exit

    def toggle(self):
        # Set toggled flag so inputs are skipped one cycle
        self._toggled = True
        self.main_menu.toggle()

    def is_enabled(self):
        return self.main_menu.is_enabled()

    def _current_widget(self):
        current_widget = self.main_menu.get_current().get_selected_widget()
        logger.debug(
            "Current selected widget is {}".format(current_widget)
        )
        return current_widget

    def is_textinput_widget(self):
        """
        Returns if current widget is textinput.
        """
        if isinstance(self._current_widget(), pygame_menu.widgets.TextInput):
            logger.debug("Text input widget found.")
            return True
        else:
            return False

    def set_textinput_widget(self, text):
        """
        Set the text of the current text widget
        """
        if self.is_textinput_widget():
            self._current_widget().set_value(text)

    def _save_wifi_config(self):
        """
        Save the wifi configuration.
        """
        wifi.set_wifi_config(self.networks)

    def _add_wifi_config(self):
        """
        Add a wifi configuration
        """
        network = {}
        network['ssid'] = "Change me"
        network['psk'] = ""
        network['id'] = len(self.networks) + 1
        logger.debug("Adding blank network: {}".format(network))
        self.networks.append(network)
        self._generate_wifi_menu()
        self.main_menu._open(self.wifi_menu)

    def _remove_wifi_config(self):
        """
        Remove a wifi configuration.
        """
        menu_data = list(
            self.main_menu.get_current().get_input_data().values()
        )
        menu_id = self.main_menu.get_current().get_id()
        logger.debug("WiFi config menu data: {}".format(menu_data))

        for network in self.networks:
            if network['id'] == self.networks_menu[menu_id]['id']:
                self.networks.remove(network)
                break
        self._generate_wifi_menu()
        self.main_menu._open(self.wifi_menu)

    def _generate_font_size(
        self,
        width,
        small_width,
        small_size,
        large_width,
        large_size
    ):
        """
        Generates the font size based on a linear equation.

        Parameters
        ----------
        width : int
            The width of the screen size to generate font size.
        small_width : int
            The screen size width of a small screen.
        small_size : int
            The size of font that fits the small screen size.
        large_width : int
            The screen size width of a large screen.
        large_size : int
            The size of font that fits the large screen size.

        Returns
        -------
        int
            The size of font generated by screen size
        """

        slope = (large_size - small_size) / (large_width - small_width)
        intercept = small_size - (slope * small_width)

        return (slope * width) + intercept

    def _title_font_size(self, screen_width):
        """
        Generate title font size based on screen size.
        """
        FONT_SIZE_320 = 22
        FONT_SIZE_1920 = 48

        return self._generate_font_size(
            screen_width, 320, FONT_SIZE_320, 1920, FONT_SIZE_1920
        )

    def _widget_font_size(self, screen_width):
        """
        Generate font size based on screen size.
        """
        FONT_SIZE_320 = 16
        FONT_SIZE_1920 = 28

        return self._generate_font_size(
            screen_width, 320, FONT_SIZE_320, 1920, FONT_SIZE_1920
        )

    def _theme(self):
        """
        Generate default theme for menus
        """
        self.theme = pygame_menu.themes.THEME_DEFAULT.copy()
        self.theme.title_bar_style = pygame_menu.widgets.MENUBAR_STYLE_SIMPLE
        self.theme.title_font = pygame_menu.font.FONT_8BIT
        self.theme.title_font_size = int(
            self._title_font_size(self.SCREEN_WIDTH)
        )
        self.theme.menubar_close_button = False
        self.theme.widget_font = pygame_menu.font.FONT_NEVIS
        self.theme.widget_font_size = int(
            self._widget_font_size(self.SCREEN_WIDTH)
        )
        self.theme.selection_color = (255, 0, 0)

    def _main_menu(self):
        """
        Generate main menu.
        """
        screen_width = pygame.display.get_surface().get_width()
        screen_height = pygame.display.get_surface().get_height()

        self.main_menu = pygame_menu.Menu(
            width=screen_width,
            height=screen_height,
            theme=self.theme,
            title='Main Menu'
        )

        self.main_menu.add_button('Wifi networks', self._generate_wifi_menu())
        self.main_menu.add_button('Save config', self._save_wifi_config)
        self.main_menu.add_button('Options', self.option_menu)
        self.main_menu.add_button('Quit', self.exit)

    def _option_menu(self):
        """
        Generate options menu.
        """
        screen_width = pygame.display.get_surface().get_width()
        screen_height = pygame.display.get_surface().get_height()

        self.option_menu = pygame_menu.Menu(
            width=screen_width,
            height=screen_height,
            theme=self.theme,
            title='Options'
        )
        self.option_menu.add_button('Back', pygame_menu.events.BACK)

    def _wifi_menu(self):
        """
        Generate WiFi list menu.
        """
        self.wifi_menu = pygame_menu.Menu(
            width=self.SCREEN_WIDTH,
            height=self.SCREEN_HEIGHT,
            theme=self.theme,
            title="WiFi networks"
        )

    def _generate_wifi_config_menu(self, network, show_password=True):
        """
        Create menu for WiFi configs.
        Creates a mapping for each widget
        """
        widget_map = {}

        network_menu = pygame_menu.Menu(
            height=self.SCREEN_HEIGHT,
            width=self.SCREEN_WIDTH,
            theme=self.theme,
            title="Edit WiFi"
        )

        if 'ssid' in network:
            ssid_widget = network_menu.add_text_input(
                'SSID: ',
                default=network['ssid']
            )
        else:
            ssid_widget = network_menu.add_text_input(
                'SSID: '
            )

        if show_password:
            if 'psk' in network:
                psk_widget = network_menu.add_text_input(
                    'Password: ',
                    default=network['psk'],
                    password=False
                )
            else:
                psk_widget = network_menu.add_text_input(
                    'Password: ',
                    password=False
                )
        else:
            psk_widget = network_menu.add_text_input(
                'Password: ',
                password=True
            )

        if 'priority' in network:
            priority_widget = network_menu.add_text_input(
                'Priority: ',
                default=network['priority']
            )
        else:
            priority_widget = network_menu.add_text_input(
                'Priority: '
            )

        if 'id_str' in network:
            idstr_widget = network_menu.add_text_input(
                'ID String: ',
                default=network['id_str']
            )
        else:
            idstr_widget = network_menu.add_text_input(
                'ID String: '
            )

        network_menu.add_button(
            '< Remove >',
            self._remove_wifi_config
        )

        network_menu.add_button(
            'Back',
            self._wifi_config_menu_back
        )

        widget_map['menu'] = network_menu
        widget_map['ssid'] = ssid_widget
        widget_map['psk'] = psk_widget
        widget_map['priority'] = priority_widget
        widget_map['id_str'] = idstr_widget

        #return network_menu
        return widget_map

    def _wifi_config_menu_back(self):
        """
        Save wifi config and go back
        """
        logger.debug("Set WiFi config array")
        menu_data = list(
            self.main_menu.get_current().get_input_data().values()
        )
        menu_id = self.main_menu.get_current().get_id()
        logger.debug("WiFi config menu data: {}".format(menu_data))

        for network in self.networks:
            if network['id'] == self.networks_menu[menu_id]['id']:
                # We assume the dict values will be in menu order
                # Changed this to use a dict mapper
                network_ssid = self.networks_menu[menu_id]['ssid'].get_value()
                network_psk = self.networks_menu[menu_id]['psk'].get_value()
                network_priority = self.networks_menu[menu_id]['priority'].get_value()
                network_id_str = self.networks_menu[menu_id]['id_str'].get_value()

                network['ssid'] = network_ssid
                network['psk'] = network_psk
                # Skip if blank
                if network_priority != '':
                    network['priority'] = network_priority
                else:
                    logger.debug("Blank priority detected. Skipping...")
                    # Remove key if exists
                    if 'priority' in network:
                        del network['priority']
                # Skip if blank
                if network_id_str != '':
                    network['id_str'] = network_id_str
                else:
                    logger.debug("Blank ID string detected. Skipping...")
                    # Remove key if exists
                    if 'id_str' in network:
                        del network['id_str']
                break

        logger.debug("Networks list: {}".format(self.networks))
        # Go back to previous menu
        self.main_menu.reset(1)
        # Change name of button to SSID in case it has changed
        self._current_widget().set_title(network_ssid)

    def _generate_wifi_menu(self):
        """
        Dynamically generate WiFi menu based on reading
        the wpa_supplicant.conf file.
        """
        self.networks_menu = {}
        self.wifi_menu.clear()
        for network in self.networks:
            if 'ssid' in network:
                # Generate config menu
                #network_menu = self._generate_wifi_config_menu(network)
                widget_map = self._generate_wifi_config_menu(network)
                network_menu = widget_map['menu']
                widget_map['id'] = network['id']
                self.networks_menu[network_menu.get_id()] = widget_map
                # Add wifi button with generated menu as action
                self.wifi_menu.add_button(
                    network['ssid'],
                    network_menu
                )

        logger.debug("WiFi and Menu ID mapping: {}".format(self.networks_menu))
        self.wifi_menu.add_button('< Add >', self._add_wifi_config)
        self.wifi_menu.add_button('Back', pygame_menu.events.BACK)
        return self.wifi_menu

    def update(self, events, **kwargs):
        """
        Update loop for the menu.
        """
        if self.main_menu.is_enabled() and not self._toggled:
            self.main_menu.update(events)
            self.main_menu.draw(pygame.display.get_surface())
        # Reset toggled flag after skipping events
        if self._toggled:
            self._toggled = False


class keyboard:
    """
    A class that controls the virtual keyboard.
    """
    layout = None
    keyboard = None
    screen = None
    _toggled = False

    def __init__(self, screen):
        self.screen = screen
        self.layout = pygame_vkeyboard.VKeyboardLayout(
            pygame_vkeyboard.VKeyboardLayout.QWERTY,
            allow_uppercase=True,
            allow_special_chars=True,
            allow_space=True
        )
        self.keyboard = pygame_vkeyboard.VKeyboard(
            surface=self.screen,
            text_consumer=self._consumer,
            main_layout=self.layout,
            joystick_navigation=True,
            show_text=True
        )
        # disable the keyboard to start
        self.keyboard.disable()

    def _consumer(self, text):
        pass

    def is_enabled(self):
        return self.keyboard.is_enabled()

    def get_text(self):
        """
        Get text input from keyboard
        """
        return self.keyboard.get_text()

    def show(self):
        """
        Show the keyboard on the screen
        """
        self.keyboard.disable()

    def hide(self):
        """
        Hide the keyboard on the screen
        """
        self.keyboard.enable()

    def toggle(self):
        """
        Hides or unhides the keyboard.
        """
        # Set toggled flag so inputs are skipped one cycle
        self._toggled = True
        if self.keyboard.is_enabled():
            self.keyboard.disable()
        else:
            self.keyboard.enable()
            self.keyboard.set_text("")

    def update(self, events):
        """
        Update the keyboard
        """
        if self.keyboard.is_enabled() and not self._toggled:
            self.keyboard.update(events)
            self.keyboard.draw(self.screen)
        # Reset toggled flag
        if self._toggled:
            self._toggled = False
